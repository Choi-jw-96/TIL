# 자바스크립트 문법

## 개요
[StandardJS](https://standardjs.com/rules-kokr.html)
### 규칙
- 들여쓰기는 2칸
- 문자열은 작은따움표
- 쉼표, 연산자 사이 공백
- 세미콜론을 사용하지 않는다


## 변수
### 식별자 명 작성 규칙
- $, _ 로 시작
- 대소문자 구문(클라스명 빼고 소문자로 시작)
- 예약어 금지

1. **카멜케이스**
: 변수 객체 함수에 사용
2. 파스칼 케이스
: 클래스, 생상자에 사용
3. 대문자 스네이크 케이스
:상수같이 변하지 않는 값에 사용

### [변수선언 키워드](01.html)
1. **let**
- **블록 스코프(중괄호의 내부)**를 갖는 지역 변수를 선언 (=블록의 바깥에서는 접근할 수 없음)
- **재할당 가능**  & 재선언 불가능

2. **const**
- 블록 스코프를 갖는 지역변수
- **재할당 불가능** & 재선언 불가능
- 반드시 초기값 필요!

3. var

기본적으로 const 사용하다 재할당이 필요한 경우 let사용


## 데이터 타입
### 원시 자료형
: Number, String, Boolean, undifined, null

변수에 값이 직접 저장이 되는 자료형(불변, **값**이 복사)

1. Number
정수 또는 실수형 숫자를 표현하는 자료형
(NaN : 수로 나타낼수 없는 값)

2. String
- +로 문자열 끼리 붙일 수 있음
- *-는 안됨
- Template Literal(`) : 문자열 사이에 변수 사입 가능
```javascript
const message = `홍길동의 나이는 ${age}입니다`
```

3. null 
변수의 값이 없음을 의도적으로 표현할 때

4. undefined
변수 선언 후 직접 할당하지 않았으면 자동을 할당



### 참조 자료형
: Objects (Object, Array, Function)

객체의 주소가 저장되는 자료형(가변, **주소**가 복사)


## 연산자
1. 할당 연산자
: 오른쪽에 있는 피연산자의 결과를 왼쪽에 할당
++, +=, --. -=
2. 비교연산자
3. 동등연산자(==)
: 같은 값으로 평가되는지 알아봄
 예상치 못한 결과를 발생할 수 있음으로 대도록 쓰지 말자
4. **일치 연산자 (===)**
: 같은 객체, 타입등이 똑같은가 비교
 엄격한 비교가 이뤄진다
5. 논리 연산자

|뜻|표현|
|-|-|
|and| && |
|or| || |
|not| ! |

## [조건문](02.html)
### if (조건분) { 명령문} else if (조건분) { 명령문} else {명령문}
조건표현식의 결과값을 boolean타입으로 변환 후 참/거짓


## [반복문](03.html)
### while (조건문) {}
조건문이 참이기만 하면 문장을 계속 수행

break continue 사용가능

const 불가능

### for ([초기문]; [조건문]; [증감문])
break, continue가능

초기문 실행 → 조건문 평가 → 증감문 실행

const 불가능

### for (.. in object)
객체(참조자료형)(파이썬의 딕셔너리)의 속성을 순회할때 사용

인덱스가 아닌 속성값을 적용

const 가능


### for (... of object)
반복가능한 객체(원시자료형)(배열(리스트) 문자열)를 순환할때 사용

const 가능
---
## 참고
### var 
- 재할당 & 재선언 가능
- "호이스팅"되는 특성(var로 선언한 변수는 선언만으로 끌어올려짐)
```java script
    consol.log(a)
    var a = 1 
    // error가 아닌 undefined
```
- 참수 스코프(함수의 중괄호 내부를 가리킴)를 가짐
- const, let을 안쓰면 자동으로 var가 생성

### NaN
- 숫자로 읽을 수 없는 경우
- 결과가 허수인 계산식
- 피 연산자가 NaN
- 정의할 수 없는 계산식
- 문자열을 포함하여 덧셈이 아닌 계산식

### 반복문 사용시 const 및 let
- for문에서는 재할당 즉, let만 사용
- for in, for of 에서는 반복마다 새로운 정의라서 const도 에러가 발생하지 않믐